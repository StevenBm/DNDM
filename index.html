<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Master View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        #controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            padding: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 100;
            flex-wrap: wrap;
        }
        button {
            background: #4a4a4a;
            color: #fff;
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }
        button:hover {
            background: #5a5a5a;
        }
        button.active {
            background: #2a7fff;
        }
        input[type="file"], select {
            font-size: 11px;
            color: #fff;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            padding: 6px;
            border-radius: 4px;
        }
        select {
            cursor: pointer;
        }
        /* Dropdown menu styles */
        .dropdown-container {
            position: relative;
            display: inline-block;
        }
        .dropdown-btn {
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            color: #fff;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            min-width: 180px;
            text-align: left;
        }
        .dropdown-btn:hover {
            background: #3a3a3a;
        }
        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            min-width: 200px;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: visible;
            z-index: 1000;
            margin-top: 2px;
        }
        .dropdown-menu.show {
            display: block;
        }
        .dropdown-item {
            padding: 8px 32px 8px 12px;
            cursor: pointer;
            color: #fff;
            font-size: 12px;
            position: relative;
            white-space: nowrap;
        }
        .dropdown-item:hover {
            background: #3a3a3a;
        }
        .dropdown-item.has-submenu {
            position: relative;
        }
        .dropdown-item.has-submenu::after {
            content: '‚ñ∏';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
        }
        .submenu {
            display: none;
            position: fixed;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            min-width: 200px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1001;
        }
        .dropdown-item.has-submenu:hover .submenu {
            display: block;
        }
        input[type="text"] {
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            font-size: 12px;
            width: 120px;
        }
        #mapContainer {
            position: fixed;
            top: 45px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
            background: #0a0a0a;
        }
        #mapCanvas {
            position: relative;
            margin: 20px auto;
            display: block;
            cursor: crosshair;
        }
        #mapCanvas.move-mode {
            cursor: move;
        }
        .label {
            font-size: 11px;
            color: #aaa;
            margin-left: 5px;
        }
        .status {
            color: #2a7fff;
            font-size: 11px;
        }
        .error {
            color: #ff2a2a;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="dropdown-container">
            <button class="dropdown-btn" id="mapLibraryBtn">Select Map...</button>
            <div class="dropdown-menu" id="mapLibraryMenu"></div>
        </div>
        <input type="file" id="mapUpload" accept="image/*">
        <button id="addPlayer">+ Player</button>
        <button id="addEnemy">+ Enemy</button>
        <input type="text" id="tokenName" placeholder="Token name">
        <button id="clearTokens">Clear Tokens</button>
        <span class="label">Mode:</span>
        <button id="modeMove" class="active">Move</button>
        <button id="modePlace">Place</button>
        <span class="status" id="status">üîÑ Connecting...</span>
		<button id="toggleFog" class="active">‚òÅÔ∏è Fog: ON</button>
    </div>
    <div id="mapContainer">
        <canvas id="mapCanvas"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        
        let db = null;
        let mapImage = null;
        let tokens = [];
        let selectedToken = null;
        let dragOffset = { x: 0, y: 0 };
        let mode = 'move';
        let placeType = null;
        let playerCount = 0;
        let enemyCount = 0;
		let fogEnabled = true;
		let visionRadius = 150; // radius around players visible to them

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBJeBvSKJucgU4UrWQVWSzexP9djl0wk0w",
            authDomain: "dnd-mapshare.firebaseapp.com",
            databaseURL: "https://dnd-mapshare-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "dnd-mapshare",
            storageBucket: "dnd-mapshare.firebasestorage.app",
            messagingSenderId: "624008039203",
            appId: "1:624008039203:web:46ee20fd32f7d8f4f95a96"
        };

        // Initialize Firebase
        try {
            const app = initializeApp(firebaseConfig);
            db = getDatabase(app);
            statusEl.textContent = '‚úì Connected to Firebase';
            loadState();
        } catch (e) {
            statusEl.textContent = '‚úó Firebase connection failed';
            statusEl.classList.add('error');
            console.error('Firebase init error:', e);
        }

        // Map library - will be populated dynamically
        let mapLibrary = {};

        // Dynamically scan maps folder structure
        async function scanMapsFolder() {
            try {
                // Try to fetch the maps directory listing from GitHub
                // Note: This requires your repo to be public or use GitHub API with token
                const repoOwner = 'StevenBm'; // CHANGE THIS
                const repoName = 'DNDM'; // CHANGE THIS
                const branch = 'main'; // or 'master'
                
                const response = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/git/trees/${branch}?recursive=1`);
                const data = await response.json();
                
                if (data.tree) {
                    // Filter for files in maps/ directory
                    const mapFiles = data.tree.filter(item => 
                        item.path.startsWith('maps/') && 
                        item.type === 'blob' &&
                        /\.(jpg|jpeg|png|gif|webp)$/i.test(item.path)
                    );
                    
                    // Build hierarchical structure
                    mapLibrary = {};
                    mapFiles.forEach(file => {
                        const parts = file.path.split('/');
                        // Remove 'maps' and filename
                        const pathParts = parts.slice(1, -1);
                        const filename = parts[parts.length - 1];
                        const mapName = filename.replace(/\.(jpg|jpeg|png|gif|webp)$/i, '')
                            .replace(/[-_]/g, ' ')
                            .replace(/\b\w/g, l => l.toUpperCase());
                        
                        // Build nested structure
                        let current = mapLibrary;
                        pathParts.forEach((part, index) => {
                            const displayName = part.replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            if (index === pathParts.length - 1) {
                                // Last level - store the map
                                if (!current[displayName]) current[displayName] = {};
                                current[displayName][mapName] = file.path;
                            } else {
                                // Create nested level
                                if (!current[displayName]) current[displayName] = {};
                                current = current[displayName];
                            }
                        });
                    });
                    
                    buildMapDropdown();
                }
            } catch (e) {
                console.error('Failed to scan maps folder:', e);
                // Fallback to manual library if API fails
                mapLibrary = {
                    "Story A": {
                        "Town A": {
                            "Town Square": "maps/story-a/town-a/townsquare.jpg",
                            "Mayor House": "maps/story-a/town-a/mayorhouse.jpg"
                        }
                    }
                };
                buildMapDropdown();
            }
        }

        // Build dropdown from mapLibrary object
        function buildMapDropdown() {
            const menu = document.getElementById('mapLibraryMenu');
            menu.innerHTML = '';
            
            function createMenuItems(obj, container) {
                for (const [key, value] of Object.entries(obj)) {
                    const item = document.createElement('div');
                    item.className = 'dropdown-item';
                    
                    if (typeof value === 'string') {
                        // It's a map path - clickable item
                        item.textContent = key;
                        item.addEventListener('click', () => {
                            loadMapFromUrl(value);
                            closeDropdown();
                        });
                    } else if (typeof value === 'object' && value !== null) {
                        // It's a folder - create submenu
                        item.textContent = key;
                        item.classList.add('has-submenu');
                        
                        const submenu = document.createElement('div');
                        submenu.className = 'submenu';
                        createMenuItems(value, submenu);
                        item.appendChild(submenu);
                        
                        // Position submenu on hover
                        item.addEventListener('mouseenter', () => {
                            const rect = item.getBoundingClientRect();
                            submenu.style.left = rect.right + 'px';
                            submenu.style.top = rect.top + 'px';
                        });
                    }
                    
                    container.appendChild(item);
                }
            }
            
            createMenuItems(mapLibrary, menu);
        }

        // Dropdown toggle
        document.getElementById('mapLibraryBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            const menu = document.getElementById('mapLibraryMenu');
            menu.classList.toggle('show');
        });

        function closeDropdown() {
            document.getElementById('mapLibraryMenu').classList.remove('show');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown-container')) {
                closeDropdown();
            }
        });

        scanMapsFolder();

        function loadMapFromUrl(url) {
            const img = new Image();
			fogEnabled = true;
			document.getElementById('toggleFog').textContent = '‚òÅÔ∏è Fog: ON';
			document.getElementById('toggleFog').classList.add('active');
            img.onload = () => {
                mapImage = img;
                canvas.width = img.width;
                canvas.height = img.height;
                renderMap();
                saveState();
            };
            img.onerror = () => {
                alert('Failed to load map from: ' + url);
            };
            img.src = url;
        }

        function loadState() {
            if (!db) return;
            const stateRef = ref(db, 'gameState');
            onValue(stateRef, (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    // Load map if it exists and is different
                    if (data.mapData && (!mapImage || canvas.toDataURL('image/jpeg', 0.7) !== data.mapData)) {
                        const img = new Image();
                        img.onload = () => {
                            mapImage = img;
                            canvas.width = img.width;
                            canvas.height = img.height;
                            renderMap();
                        };
                        img.src = data.mapData;
                    }
                    // Only update tokens if we're not currently dragging
                    if (!selectedToken && data.tokens) {
                        tokens = data.tokens;
                        // Update counters based on existing tokens
                        playerCount = tokens.filter(t => t.type === 'player').length;
                        enemyCount = tokens.filter(t => t.type === 'enemy').length;
                        if (mapImage) {
                            renderMap();
                        }
                    }
                }
            });
        }

        let saveTimeout = null;

        async function saveState() {
            if (!db) return;
            
            // Clear any pending save
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            // Debounce saves to prevent conflicts
            saveTimeout = setTimeout(async () => {
                const mapData = mapImage ? canvas.toDataURL('image/jpeg', 0.7) : null;
				const state = {
					mapData: mapData,
					tokens: tokens,
					fog: {
						enabled: fogEnabled,
						radius: visionRadius
					},
					timestamp: Date.now()
				};
                
                console.log('Saving state, map exists:', !!mapData, 'tokens:', tokens.length);
                
                try {
                    await set(ref(db, 'gameState'), state);
                    statusEl.textContent = '‚úì Synced';
                    setTimeout(() => {
                        statusEl.textContent = '‚úì Connected to Firebase';
                    }, 1000);
                } catch (e) {
                    statusEl.textContent = '‚úó Sync failed';
                    statusEl.classList.add('error');
                    console.error('Save error:', e);
                }
            }, 100);
        }

        // Map upload
        document.getElementById('mapUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        mapImage = img;
                        canvas.width = img.width;
                        canvas.height = img.height;
                        renderMap();
                        saveState();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        function renderMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (mapImage) {
                ctx.drawImage(mapImage, 0, 0);
            }
            renderTokens();
        }

        function renderTokens() {
            tokens.forEach(token => {
                ctx.beginPath();
                ctx.arc(token.x, token.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = token.type === 'player' ? 'rgba(42, 127, 255, 0.8)' : 'rgba(255, 42, 42, 0.8)';
                ctx.fill();
                ctx.strokeStyle = token.type === 'player' ? '#2a7fff' : '#ff2a2a';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(token.name, token.x, token.y);
            });
        }

        // Mode switching
        document.getElementById('modeMove').addEventListener('click', () => {
            mode = 'move';
            placeType = null;
            canvas.classList.remove('crosshair');
            canvas.classList.add('move-mode');
            document.getElementById('modeMove').classList.add('active');
            document.getElementById('modePlace').classList.remove('active');
        });

        document.getElementById('modePlace').addEventListener('click', () => {
            mode = 'place';
            canvas.classList.remove('move-mode');
            document.getElementById('modeMove').classList.remove('active');
            document.getElementById('modePlace').classList.add('active');
        });

        // Add tokens
        document.getElementById('addPlayer').addEventListener('click', () => {
            mode = 'place';
            placeType = 'player';
            canvas.classList.remove('move-mode');
            document.getElementById('modePlace').classList.add('active');
            document.getElementById('modeMove').classList.remove('active');
        });

        document.getElementById('addEnemy').addEventListener('click', () => {
            mode = 'place';
            placeType = 'enemy';
            canvas.classList.remove('move-mode');
            document.getElementById('modePlace').classList.add('active');
            document.getElementById('modeMove').classList.remove('active');
        });
		document.getElementById('toggleFog').addEventListener('click', () => {
			fogEnabled = !fogEnabled;
			const btn = document.getElementById('toggleFog');
			btn.textContent = fogEnabled ? '‚òÅÔ∏è Fog: ON' : 'üå§Ô∏è Fog: OFF';
			btn.classList.toggle('active', fogEnabled);
			saveState();
		});
        // Canvas interactions
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (mode === 'place' && placeType) {
                const name = document.getElementById('tokenName').value || 
                    (placeType === 'player' ? 'P' + (++playerCount) : 'E' + (++enemyCount));
                tokens.push({ x, y, type: placeType, name });
                document.getElementById('tokenName').value = '';
                renderMap();
                saveState();
                mode = 'move';
                placeType = null;
                canvas.classList.add('move-mode');
                document.getElementById('modeMove').classList.add('active');
                document.getElementById('modePlace').classList.remove('active');
            } else if (mode === 'move') {
                selectedToken = tokens.find(t => 
                    Math.sqrt((t.x - x) ** 2 + (t.y - y) ** 2) < 20
                );
                if (selectedToken) {
                    dragOffset = { x: x - selectedToken.x, y: y - selectedToken.y };
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (selectedToken && mode === 'move') {
                const rect = canvas.getBoundingClientRect();
                selectedToken.x = e.clientX - rect.left - dragOffset.x;
                selectedToken.y = e.clientY - rect.top - dragOffset.y;
                renderMap();
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (selectedToken) {
                selectedToken = null;
                saveState();
            }
        });

        // Clear tokens only
        document.getElementById('clearTokens').addEventListener('click', () => {
            if (confirm('Clear all tokens?')) {
                tokens = [];
                playerCount = 0;
                enemyCount = 0;
                renderMap();
                saveState();
            }
        });

        // Delete token on right-click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const index = tokens.findIndex(t => 
                Math.sqrt((t.x - x) ** 2 + (t.y - y) ** 2) < 20
            );
            if (index !== -1) {
                tokens.splice(index, 1);
                renderMap();
                saveState();
            }
        });

        canvas.classList.add('move-mode');
    </script>
</body>
</html>