<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Player View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            z-index: 100;
            text-align: center;
            font-size: 12px;
        }
        #mapContainer {
            position: fixed;
            top: 30px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mapCanvas {
            display: block;
            transform-origin: center center;
        }
        .status {
            color: #2a7fff;
        }
        .waiting {
            color: #ff9500;
        }
        .error {
            color: #ff2a2a;
        }
    </style>
</head>
<body>
    <div id="header">
        <span class="status waiting" id="status">⏳ Connecting...</span>
    </div>
    <div id="mapContainer">
        <canvas id="mapCanvas"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, onValue } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        
        console.log('%c=== PLAYER VIEW LOADED ===', 'color: #00ff00; font-size: 20px; font-weight: bold');
        console.log('This is the PLAYER view - READ ONLY');
        
        let db = null;
        let mapImage = null;
        let tokens = [];
        let currentFog = { enabled: true, radius: 150 };
        let tokenImages = {};
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let lastMapData = null;
		let fogLayerImage = null;
		let fogLayerEnabled = false;
        const firebaseConfig = {
            apiKey: "AIzaSyBJeBvSKJucgU4UrWQVWSzexP9djl0wk0w",
            authDomain: "dnd-mapshare.firebaseapp.com",
            databaseURL: "https://dnd-mapshare-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "dnd-mapshare",
            storageBucket: "dnd-mapshare.firebasestorage.app",
            messagingSenderId: "624008039203",
            appId: "1:624008039203:web:46ee20fd32f7d8f4f95a96"
        };

        try {
            const app = initializeApp(firebaseConfig);
            db = getDatabase(app);
            statusEl.textContent = '⏳ Waiting for DM...';
            statusEl.className = 'status waiting';
            listenForUpdates();
        } catch (e) {
            statusEl.textContent = '✗ Connection failed';
            statusEl.className = 'status error';
            console.error('Firebase init error:', e);
        }

        function loadTokenImage(imagePath) {
            if (!tokenImages[imagePath]) {
                const img = new Image();
                img.onload = () => {
                    tokenImages[imagePath] = img;
                    renderMap();
                };
                img.onerror = () => {
                    console.error('Failed to load token image:', imagePath);
                };
                img.src = imagePath;
            }
        }

        function listenForUpdates() {
            if (!db) return;
            
            const stateRef = ref(db, 'gameState');
            onValue(stateRef, (snapshot) => {
                const data = snapshot.val();
                
                if (!data) {
                    statusEl.textContent = '⏳ Waiting for DM to upload map...';
                    statusEl.className = 'status waiting';
                    return;
                }
                
                console.log('%cPLAYER UPDATE', 'color: #00ff00; font-weight: bold');
                console.log('Fog:', data.fog);
                console.log('Tokens:', data.tokens?.length);
                console.log('Zoom:', data.zoom, 'Pan:', data.pan);
                
                // Update fog settings
                if (data.fog) {
                    currentFog = data.fog;
                    console.log('Updated fog settings:', currentFog);
                }
// Update fog layer enabled state
				if (data.fogLayerEnabled !== undefined) {
					fogLayerEnabled = data.fogLayerEnabled;
					console.log('Fog layer enabled:', fogLayerEnabled);
				}

				// Load fog layer image
				if (data.fogLayer) {
					const fogImg = new Image();
					fogImg.onload = () => {
						fogLayerImage = fogImg;
						console.log('Fog layer image loaded');
						renderMap();
					};
					fogImg.src = data.fogLayer;
				} else {
					fogLayerImage = null;
					if (mapImage) renderMap();
				}
                // Update zoom/pan
                if (data.zoom !== undefined) {
                    zoom = data.zoom;
                }
                if (data.pan) {
                    panX = data.pan.x;
                    panY = data.pan.y;
                }
                
                // Store all tokens for visibility checking
                const allTokens = data.tokens || [];
                const playerTokens = allTokens.filter(t => t.type === 'player');
                
                // Determine which tokens to show
                if (currentFog.enabled && playerTokens.length > 0) {
                    // Fog ON: show players + enemies within vision range + all items
                    tokens = allTokens.filter(t => {
                        if (t.type === 'player') return true;
                        if (t.type === 'item') return true; // Always show items
                        
                        // Check if enemy is within vision range of any player
                        if (t.type === 'enemy') {
                            return playerTokens.some(player => {
                                const dist = Math.sqrt(
                                    (player.x - t.x) ** 2 + 
                                    (player.y - t.y) ** 2
                                );
                                return dist <= currentFog.radius;
                            });
                        }
                        
                        return false;
                    });
                } else {
                    // Fog OFF: show everything
                    tokens = allTokens;
                }
                
                console.log('Visible tokens:', tokens.length, '(', tokens.filter(t => t.type === 'player').length, 'players,', tokens.filter(t => t.type === 'enemy').length, 'enemies,', tokens.filter(t => t.type === 'item').length, 'items)');
                
                tokens.forEach(token => {
                    if (token.image && !tokenImages[token.image]) {
                        loadTokenImage(token.image);
                    }
                });
                // Update map only if it changed
                if (data.mapData && data.mapData !== lastMapData) {
                    lastMapData = data.mapData;
                    const img = new Image();
                    img.onload = () => {
                        mapImage = img;
                        canvas.width = img.width;
                        canvas.height = img.height;
                        renderMap();
                        statusEl.textContent = '✓ Connected';
                        statusEl.className = 'status';
                    };
                    img.onerror = () => {
                        statusEl.textContent = '✗ Map load failed';
                        statusEl.className = 'status error';
                    };
                    img.src = data.mapData;
                } else if (mapImage) {
                    renderMap();
                }
            }, (error) => {
                statusEl.textContent = '✗ Connection error';
                statusEl.className = 'status error';
                console.error('Firebase read error:', error);
            });
        }

     function renderMap() {
    if (!mapImage) return;

    console.log('%c=== RENDERING ===', 'color: #00ff00; font-weight: bold');
    console.log('Tokens:', tokens.length);
    console.log('Fog enabled:', currentFog.enabled, 'Radius:', currentFog.radius);

    // Create an offscreen canvas for clean rendering
    const offscreen = document.createElement('canvas');
    offscreen.width = canvas.width;
    offscreen.height = canvas.height;
    const offCtx = offscreen.getContext('2d');
    
    // Apply transform on offscreen canvas
    offCtx.save();
    offCtx.translate(canvas.width / 2, canvas.height / 2);
    offCtx.scale(zoom, zoom);
    offCtx.translate(-canvas.width / 2 + panX / zoom, -canvas.height / 2 + panY / zoom);
    
    // Draw map
    offCtx.drawImage(mapImage, 0, 0);

    // Draw all visible tokens
    tokens.forEach(token => {
        const tokenSize = (token.size || 1) * 20;
        const imageSize = tokenSize * 2;
        
        if (token.image && tokenImages[token.image]) {
            const img = tokenImages[token.image];
            
            offCtx.save();
            offCtx.beginPath();
            offCtx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
            offCtx.closePath();
            offCtx.clip();
            offCtx.drawImage(img, token.x - tokenSize, token.y - tokenSize, imageSize, imageSize);
            offCtx.restore();
            
            offCtx.beginPath();
            offCtx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
            offCtx.strokeStyle = token.type === 'player' ? '#2a7fff' : token.type === 'enemy' ? '#ff2a2a' : '#ffaa00';
            offCtx.lineWidth = 3;
            offCtx.stroke();
        } else {
            offCtx.beginPath();
            offCtx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
            if (token.type === 'player') {
                offCtx.fillStyle = 'rgba(42, 127, 255, 0.8)';
                offCtx.strokeStyle = '#2a7fff';
            } else if (token.type === 'enemy') {
                offCtx.fillStyle = 'rgba(255, 42, 42, 0.8)';
                offCtx.strokeStyle = '#ff2a2a';
            } else if (token.type === 'item') {
                offCtx.fillStyle = 'rgba(255, 170, 0, 0.8)';
                offCtx.strokeStyle = '#ffaa00';
            }
            offCtx.fill();
            offCtx.lineWidth = 3;
            offCtx.stroke();
        }
        
        // Draw name
        offCtx.fillStyle = '#fff';
        offCtx.font = 'bold 11px Arial';
        offCtx.textAlign = 'center';
        offCtx.textBaseline = 'top';
        offCtx.strokeStyle = '#000';
        offCtx.lineWidth = 3;
        offCtx.strokeText(token.name, token.x, token.y + tokenSize + 3);
        offCtx.fillText(token.name, token.x, token.y + tokenSize + 3);
    });

    // Restore transform before applying fog
    offCtx.restore();

    // Apply vision fog first (if enabled)
  const fog = currentFog || { enabled: false, radius: 150 };

// We need to combine vision circles fog AND painted fog
// Both can CLEAR fog, so we take the MINIMUM (lightest) of both
if (fog.enabled || (fogLayerEnabled && fogLayerImage)) {
    console.log('Creating combined fog mask');
    
    // Create the final mask canvas
    const combinedMask = document.createElement('canvas');
    combinedMask.width = canvas.width;
    combinedMask.height = canvas.height;
    const combinedCtx = combinedMask.getContext('2d');
    
    // Start with complete darkness
    combinedCtx.fillStyle = '#000000';
    combinedCtx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Apply transform
    combinedCtx.translate(canvas.width / 2, canvas.height / 2);
    combinedCtx.scale(zoom, zoom);
    combinedCtx.translate(-canvas.width / 2 + panX / zoom, -canvas.height / 2 + panY / zoom);
    
    // Cut out vision circles (if vision fog enabled)
    if (fog.enabled) {
        const playerTokens = tokens.filter(t => t.type === 'player');
        if (playerTokens.length > 0) {
            console.log('Cutting vision circles for', playerTokens.length, 'players');
            combinedCtx.globalCompositeOperation = 'destination-out';
            playerTokens.forEach(token => {
                const gradient = combinedCtx.createRadialGradient(
                    token.x, token.y, 0,
                    token.x, token.y, fog.radius
                );
                gradient.addColorStop(0, 'rgba(0,0,0,1)');
                gradient.addColorStop(0.8, 'rgba(0,0,0,0.5)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                combinedCtx.fillStyle = gradient;
                combinedCtx.beginPath();
                combinedCtx.arc(token.x, token.y, fog.radius, 0, Math.PI * 2);
                combinedCtx.fill();
            });
        }
    }
    
    // Also cut out areas cleared by DM (painted fog layer)
    if (fogLayerEnabled && fogLayerImage) {
        console.log('Applying painted fog layer');
        // Use destination-out to clear where painted fog is transparent
        // and destination-over to keep where painted fog is black
        combinedCtx.globalCompositeOperation = 'destination-out';
        
        // Create inverted fog layer (transparent becomes opaque, opaque becomes transparent)
        const invertCanvas = document.createElement('canvas');
        invertCanvas.width = fogLayerImage.width;
        invertCanvas.height = fogLayerImage.height;
        const invertCtx = invertCanvas.getContext('2d');
        
        // Fill white
        invertCtx.fillStyle = '#ffffff';
        invertCtx.fillRect(0, 0, invertCanvas.width, invertCanvas.height);
        
        // Use destination-out to remove where fog layer is opaque
        invertCtx.globalCompositeOperation = 'destination-out';
        invertCtx.drawImage(fogLayerImage, 0, 0);
        
        // Now draw the inverted layer - this cuts out cleared areas
        combinedCtx.drawImage(invertCanvas, 0, 0);
    }
    
    // Reset composite operation
    combinedCtx.globalCompositeOperation = 'source-over';
    
    // Apply the combined mask to main canvas
    offCtx.globalAlpha = 0.95;
    offCtx.drawImage(combinedMask, 0, 0);
    offCtx.globalAlpha = 1.0;
    console.log('Combined fog applied');
}

// Now copy the complete offscreen canvas to the main canvas
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.drawImage(offscreen, 0, 0);

console.log('Render complete');}
    </script>
</body>
</html>