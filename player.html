<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Player View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            z-index: 100;
            text-align: center;
            font-size: 12px;
        }
        #mapContainer {
            position: fixed;
            top: 30px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mapCanvas {
            display: block;
            transform-origin: center center;
        }
        .status {
            color: #2a7fff;
        }
        .waiting {
            color: #ff9500;
        }
        .error {
            color: #ff2a2a;
        }
    </style>
</head>
<body>
    <div id="header">
        <span class="status waiting" id="status">⏳ Connecting...</span>
    </div>
    <div id="mapContainer">
        <canvas id="mapCanvas"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, onValue } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        
        console.log('%c=== PLAYER VIEW LOADED ===', 'color: #00ff00; font-size: 20px; font-weight: bold');
        console.log('This is the PLAYER view - READ ONLY');
        
        let db = null;
        let mapImage = null;
        let tokens = [];
        let currentFog = { enabled: true, radius: 150 };
        let tokenImages = {};
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let lastMapData = null;
		let fogLayerImage = null;
		let fogLayerEnabled = false;
		let fogLayerCanvas = null; // ADD THIS
        const firebaseConfig = {
            apiKey: "AIzaSyBJeBvSKJucgU4UrWQVWSzexP9djl0wk0w",
            authDomain: "dnd-mapshare.firebaseapp.com",
            databaseURL: "https://dnd-mapshare-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "dnd-mapshare",
            storageBucket: "dnd-mapshare.firebasestorage.app",
            messagingSenderId: "624008039203",
            appId: "1:624008039203:web:46ee20fd32f7d8f4f95a96"
        };

        try {
            const app = initializeApp(firebaseConfig);
            db = getDatabase(app);
            statusEl.textContent = '⏳ Waiting for DM...';
            statusEl.className = 'status waiting';
            listenForUpdates();
        } catch (e) {
            statusEl.textContent = '✗ Connection failed';
            statusEl.className = 'status error';
            console.error('Firebase init error:', e);
        }

        function loadTokenImage(imagePath) {
            if (!tokenImages[imagePath]) {
                const img = new Image();
                img.onload = () => {
                    tokenImages[imagePath] = img;
                    renderMap();
                };
                img.onerror = () => {
                    console.error('Failed to load token image:', imagePath);
                };
                img.src = imagePath;
            }
        }

        function listenForUpdates() {
            if (!db) return;
            
            const stateRef = ref(db, 'gameState');
            onValue(stateRef, (snapshot) => {
                const data = snapshot.val();
                
                if (!data) {
                    statusEl.textContent = '⏳ Waiting for DM to upload map...';
                    statusEl.className = 'status waiting';
                    return;
                }
                
                console.log('%cPLAYER UPDATE', 'color: #00ff00; font-weight: bold');
                console.log('Fog:', data.fog);
                console.log('Tokens:', data.tokens?.length);
                console.log('Zoom:', data.zoom, 'Pan:', data.pan);
                
                // Update fog settings
                if (data.fog) {
                    currentFog = data.fog;
                    console.log('Updated fog settings:', currentFog);
                }
// Update fog layer enabled state
				if (data.fogLayerEnabled !== undefined) {
					fogLayerEnabled = data.fogLayerEnabled;
					console.log('Fog layer enabled:', fogLayerEnabled);
				}

				// Load fog layer image
			// Load fog layer image
					if (data.fogLayer) {
						const fogImg = new Image();
						fogImg.onload = () => {
							fogLayerImage = fogImg;
							
							// Also create a canvas version for pixel sampling
							fogLayerCanvas = document.createElement('canvas');
							fogLayerCanvas.width = fogImg.width;
							fogLayerCanvas.height = fogImg.height;
							const ctx = fogLayerCanvas.getContext('2d');
							ctx.drawImage(fogImg, 0, 0);
							
							console.log('Fog layer image loaded');
							renderMap();
						};
						fogImg.src = data.fogLayer;
					} else {
						fogLayerImage = null;
						fogLayerCanvas = null;
						if (mapImage) renderMap();
					}
                // Update zoom/pan
                if (data.zoom !== undefined) {
                    zoom = data.zoom;
                }
                if (data.pan) {
                    panX = data.pan.x;
                    panY = data.pan.y;
                }
                
                // Store all tokens for visibility checking
      // Store all tokens for visibility checking
const allTokens = data.tokens || [];
const playerTokens = allTokens.filter(t => t.type === 'player');

// Determine which tokens to show
if (currentFog.enabled || fogLayerEnabled) {
    // Show players + items always
    // Show enemies if they're in cleared fog (vision circles OR painted fog cleared areas)
    tokens = allTokens.filter(t => {
        if (t.type === 'player') return true;
        if (t.type === 'item') return true;
        
        // Check if enemy is in visible area
        if (t.type === 'enemy') {
            // Check vision circles first
            const inVisionRange = currentFog.enabled && playerTokens.some(player => {
                const dist = Math.sqrt(
                    (player.x - t.x) ** 2 + 
                    (player.y - t.y) ** 2
                );
                return dist <= currentFog.radius;
            });
            
            if (inVisionRange) return true;
            
            // Check if in DM-cleared fog area
            if (fogLayerEnabled && fogLayerCanvas) {
                try {
                    // Get pixel data at enemy position
                    const ctx = fogLayerCanvas.getContext('2d');
                    const pixelData = ctx.getImageData(Math.floor(t.x), Math.floor(t.y), 1, 1).data;
                    const alpha = pixelData[3]; // Alpha channel
                    
                    // If alpha is low (transparent), fog is cleared here
                    if (alpha < 200) return true; // Less than ~78% opacity means it's cleared
                } catch (e) {
                    console.error('Error checking fog at enemy position:', e);
                }
            }
            
            return false;
        }
        
        return false;
    });
} else {
    // Fog OFF: show everything
    tokens = allTokens;
}
                
                console.log('Visible tokens:', tokens.length, '(', tokens.filter(t => t.type === 'player').length, 'players,', tokens.filter(t => t.type === 'enemy').length, 'enemies,', tokens.filter(t => t.type === 'item').length, 'items)');
                
                tokens.forEach(token => {
                    if (token.image && !tokenImages[token.image]) {
                        loadTokenImage(token.image);
                    }
                });
                // Update map only if it changed
                if (data.mapData && data.mapData !== lastMapData) {
                    lastMapData = data.mapData;
                    const img = new Image();
                    img.onload = () => {
                        mapImage = img;
                        canvas.width = img.width;
                        canvas.height = img.height;
                        renderMap();
                        statusEl.textContent = '✓ Connected';
                        statusEl.className = 'status';
                    };
                    img.onerror = () => {
                        statusEl.textContent = '✗ Map load failed';
                        statusEl.className = 'status error';
                    };
                    img.src = data.mapData;
                } else if (mapImage) {
                    renderMap();
                }
            }, (error) => {
                statusEl.textContent = '✗ Connection error';
                statusEl.className = 'status error';
                console.error('Firebase read error:', error);
            });
        }

     function renderMap() {
    if (!mapImage) return;

    console.log('%c=== RENDERING ===', 'color: #00ff00; font-weight: bold');
    console.log('Tokens:', tokens.length);
    console.log('Fog enabled:', currentFog.enabled, 'Radius:', currentFog.radius);

    // Create an offscreen canvas for clean rendering
    const offscreen = document.createElement('canvas');
    offscreen.width = canvas.width;
    offscreen.height = canvas.height;
    const offCtx = offscreen.getContext('2d');
    
    // Apply transform on offscreen canvas
    offCtx.save();
    offCtx.translate(canvas.width / 2, canvas.height / 2);
    offCtx.scale(zoom, zoom);
    offCtx.translate(-canvas.width / 2 + panX / zoom, -canvas.height / 2 + panY / zoom);
    
    // Draw map
    offCtx.drawImage(mapImage, 0, 0);

    // Draw all visible tokens
    tokens.forEach(token => {
        const tokenSize = (token.size || 1) * 20;
        const imageSize = tokenSize * 2;
        
        if (token.image && tokenImages[token.image]) {
            const img = tokenImages[token.image];
            
            offCtx.save();
            offCtx.beginPath();
            offCtx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
            offCtx.closePath();
            offCtx.clip();
            offCtx.drawImage(img, token.x - tokenSize, token.y - tokenSize, imageSize, imageSize);
            offCtx.restore();
            
            offCtx.beginPath();
            offCtx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
            offCtx.strokeStyle = token.type === 'player' ? '#2a7fff' : token.type === 'enemy' ? '#ff2a2a' : '#ffaa00';
            offCtx.lineWidth = 3;
            offCtx.stroke();
        } else {
            offCtx.beginPath();
            offCtx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
            if (token.type === 'player') {
                offCtx.fillStyle = 'rgba(42, 127, 255, 0.8)';
                offCtx.strokeStyle = '#2a7fff';
            } else if (token.type === 'enemy') {
                offCtx.fillStyle = 'rgba(255, 42, 42, 0.8)';
                offCtx.strokeStyle = '#ff2a2a';
            } else if (token.type === 'item') {
                offCtx.fillStyle = 'rgba(255, 170, 0, 0.8)';
                offCtx.strokeStyle = '#ffaa00';
            }
            offCtx.fill();
            offCtx.lineWidth = 3;
            offCtx.stroke();
        }
        
        // Draw name
        offCtx.fillStyle = '#fff';
        offCtx.font = 'bold 11px Arial';
        offCtx.textAlign = 'center';
        offCtx.textBaseline = 'top';
        offCtx.strokeStyle = '#000';
        offCtx.lineWidth = 3;
        offCtx.strokeText(token.name, token.x, token.y + tokenSize + 3);
        offCtx.fillText(token.name, token.x, token.y + tokenSize + 3);
    });

    // Restore transform before applying fog
    offCtx.restore();

    // Apply vision fog first (if enabled)
 // Apply vision fog first (if enabled)
const fog = currentFog || { enabled: false, radius: 150 };

// We need to combine vision circles fog AND painted fog
// Both can CLEAR fog, so we take the MINIMUM (lightest) of both
if (fog.enabled || (fogLayerEnabled && fogLayerImage)) {
    console.log('Creating combined fog mask');
    
    // Create the final mask canvas
    const combinedMask = document.createElement('canvas');
    combinedMask.width = canvas.width;
    combinedMask.height = canvas.height;
    const combinedCtx = combinedMask.getContext('2d');
    
    // Start with complete darkness
    combinedCtx.fillStyle = '#000000';
    combinedCtx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Apply transform
    combinedCtx.translate(canvas.width / 2, canvas.height / 2);
    combinedCtx.scale(zoom, zoom);
    combinedCtx.translate(-canvas.width / 2 + panX / zoom, -canvas.height / 2 + panY / zoom);
    
    // Cut out vision circles (if vision fog enabled) - HARD EDGE, NO GRADIENT
    if (fog.enabled) {
        const playerTokens = tokens.filter(t => t.type === 'player');
        if (playerTokens.length > 0) {
            console.log('Cutting vision circles for', playerTokens.length, 'players');
            combinedCtx.globalCompositeOperation = 'destination-out';
            playerTokens.forEach(token => {
                // Use solid fill instead of gradient for hard edge
                combinedCtx.fillStyle = 'rgba(0,0,0,1)';
                combinedCtx.beginPath();
                combinedCtx.arc(token.x, token.y, fog.radius, 0, Math.PI * 2);
                combinedCtx.fill();
            });
        }
    }
    
    // Also cut out areas cleared by DM (painted fog layer)
 // Also cut out areas cleared by DM (painted fog layer)
if (fogLayerEnabled && fogLayerImage) {
    console.log('Applying painted fog layer');
    
    // Create a fully opaque version of the fog layer
    const opaqueCanvas = document.createElement('canvas');
    opaqueCanvas.width = fogLayerImage.width;
    opaqueCanvas.height = fogLayerImage.height;
    const opaqueCtx = opaqueCanvas.getContext('2d');
    
    // Draw the fog layer
    opaqueCtx.drawImage(fogLayerImage, 0, 0);
    
    // Get image data and make all semi-transparent pixels fully opaque or fully transparent
    const imageData = opaqueCtx.getImageData(0, 0, opaqueCanvas.width, opaqueCanvas.height);
    const data = imageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
        const alpha = data[i + 3];
        // If alpha > 50% (128), make it fully black
        // If alpha < 50%, make it fully transparent
        if (alpha > 128) {
            data[i] = 0;     // R
            data[i + 1] = 0; // G
            data[i + 2] = 0; // B
            data[i + 3] = 255; // A - fully opaque
        } else {
            data[i + 3] = 0; // A - fully transparent
        }
    }
    
    opaqueCtx.putImageData(imageData, 0, 0);
    
    // Now create inverted version for cutting out
    const invertCanvas = document.createElement('canvas');
    invertCanvas.width = opaqueCanvas.width;
    invertCanvas.height = opaqueCanvas.height;
    const invertCtx = invertCanvas.getContext('2d');
    
    // Fill white
    invertCtx.fillStyle = '#ffffff';
    invertCtx.fillRect(0, 0, invertCanvas.width, invertCanvas.height);
    
    // Use destination-out to remove where fog layer is opaque
    invertCtx.globalCompositeOperation = 'destination-out';
    invertCtx.drawImage(opaqueCanvas, 0, 0);
    
    // Now draw the inverted layer - this cuts out cleared areas
    combinedCtx.globalCompositeOperation = 'destination-out';
    combinedCtx.drawImage(invertCanvas, 0, 0);
}
    
    // Reset composite operation
    combinedCtx.globalCompositeOperation = 'source-over';
    
    // Apply the combined mask to main canvas - FULL OPACITY
    offCtx.globalAlpha = 1.0;
    offCtx.drawImage(combinedMask, 0, 0);
    console.log('Combined fog applied');
}

// Now copy the complete offscreen canvas to the main canvas
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.drawImage(offscreen, 0, 0);

console.log('Render complete');}
    </script>
</body>
</html>