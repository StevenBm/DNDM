<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Player View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            z-index: 100;
            text-align: center;
            font-size: 12px;
        }
        #mapContainer {
            position: fixed;
            top: 30px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mapCanvas {
            display: block;
            transform-origin: center center;
        }
        .status {
            color: #2a7fff;
        }
        .waiting {
            color: #ff9500;
        }
        .error {
            color: #ff2a2a;
        }
    </style>
</head>
<body>
    <div id="header">
        <span class="status waiting" id="status">⏳ Connecting...</span>
    </div>
    <div id="mapContainer">
        <canvas id="mapCanvas"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, onValue } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        
        console.log('%c=== PLAYER VIEW LOADED ===', 'color: #00ff00; font-size: 20px; font-weight: bold');
        console.log('This is the PLAYER view - READ ONLY');
        
        let db = null;
        let mapImage = null;
        let tokens = [];
        let currentFog = { enabled: true, radius: 150 };
        let tokenImages = {};
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let lastMapData = null;

        const firebaseConfig = {
            apiKey: "AIzaSyBJeBvSKJucgU4UrWQVWSzexP9djl0wk0w",
            authDomain: "dnd-mapshare.firebaseapp.com",
            databaseURL: "https://dnd-mapshare-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "dnd-mapshare",
            storageBucket: "dnd-mapshare.firebasestorage.app",
            messagingSenderId: "624008039203",
            appId: "1:624008039203:web:46ee20fd32f7d8f4f95a96"
        };

        try {
            const app = initializeApp(firebaseConfig);
            db = getDatabase(app);
            statusEl.textContent = '⏳ Waiting for DM...';
            statusEl.className = 'status waiting';
            listenForUpdates();
        } catch (e) {
            statusEl.textContent = '✗ Connection failed';
            statusEl.className = 'status error';
            console.error('Firebase init error:', e);
        }

        function loadTokenImage(imagePath) {
            if (!tokenImages[imagePath]) {
                const img = new Image();
                img.onload = () => {
                    tokenImages[imagePath] = img;
                    renderMap();
                };
                img.onerror = () => {
                    console.error('Failed to load token image:', imagePath);
                };
                img.src = imagePath;
            }
        }

        function listenForUpdates() {
            if (!db) return;
            
            const stateRef = ref(db, 'gameState');
            onValue(stateRef, (snapshot) => {
                const data = snapshot.val();
                
                if (!data) {
                    statusEl.textContent = '⏳ Waiting for DM to upload map...';
                    statusEl.className = 'status waiting';
                    return;
                }
                
                console.log('%cPLAYER UPDATE', 'color: #00ff00; font-weight: bold');
                console.log('Fog:', data.fog);
                console.log('Tokens:', data.tokens?.length);
                console.log('Zoom:', data.zoom, 'Pan:', data.pan);
                
                // Update fog settings
                if (data.fog) {
                    currentFog = data.fog;
                    console.log('Updated fog settings:', currentFog);
                }
                
                // Update zoom/pan
                if (data.zoom !== undefined) {
                    zoom = data.zoom;
                }
                if (data.pan) {
                    panX = data.pan.x;
                    panY = data.pan.y;
                }
                
                // Update tokens - filter for players only
                tokens = (data.tokens || []).filter(t => t.type === 'player');
                console.log('Player tokens:', tokens.length);
                
                tokens.forEach(token => {
                    if (token.image && !tokenImages[token.image]) {
                        loadTokenImage(token.image);
                    }
                });
                
                // Update map only if it changed
                if (data.mapData && data.mapData !== lastMapData) {
                    lastMapData = data.mapData;
                    const img = new Image();
                    img.onload = () => {
                        mapImage = img;
                        canvas.width = img.width;
                        canvas.height = img.height;
                        renderMap();
                        statusEl.textContent = '✓ Connected';
                        statusEl.className = 'status';
                    };
                    img.onerror = () => {
                        statusEl.textContent = '✗ Map load failed';
                        statusEl.className = 'status error';
                    };
                    img.src = data.mapData;
                } else if (mapImage) {
                    renderMap();
                }
            }, (error) => {
                statusEl.textContent = '✗ Connection error';
                statusEl.className = 'status error';
                console.error('Firebase read error:', error);
            });
        }

        function renderMap() {
            if (!mapImage) return;

            console.log('%c=== RENDERING ===', 'color: #00ff00; font-weight: bold');
            console.log('Tokens:', tokens.length);
            console.log('Fog enabled:', currentFog.enabled, 'Radius:', currentFog.radius);

            // Create an offscreen canvas for clean rendering
            const offscreen = document.createElement('canvas');
            offscreen.width = canvas.width;
            offscreen.height = canvas.height;
            const offCtx = offscreen.getContext('2d');
            
            // Apply transform on offscreen canvas
            offCtx.save();
            offCtx.translate(canvas.width / 2, canvas.height / 2);
            offCtx.scale(zoom, zoom);
            offCtx.translate(-canvas.width / 2 + panX / zoom, -canvas.height / 2 + panY / zoom);
            
            // Draw map
            offCtx.drawImage(mapImage, 0, 0);

            // Draw all player tokens
            tokens.forEach(token => {
                const tokenSize = (token.size || 1) * 20;
                const imageSize = tokenSize * 2;
                
                if (token.image && tokenImages[token.image]) {
                    const img = tokenImages[token.image];
                    
                    offCtx.save();
                    offCtx.beginPath();
                    offCtx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
                    offCtx.closePath();
                    offCtx.clip();
                    offCtx.drawImage(img, token.x - tokenSize, token.y - tokenSize, imageSize, imageSize);
                    offCtx.restore();
                    
                    offCtx.beginPath();
                    offCtx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
                    offCtx.strokeStyle = '#2a7fff';
                    offCtx.lineWidth = 3;
                    offCtx.stroke();
                } else {
                    offCtx.beginPath();
                    offCtx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
                    offCtx.fillStyle = 'rgba(42, 127, 255, 0.8)';
                    offCtx.fill();
                    offCtx.strokeStyle = '#2a7fff';
                    offCtx.lineWidth = 3;
                    offCtx.stroke();
                }
                
                // Draw name
                offCtx.fillStyle = '#fff';
                offCtx.font = 'bold 11px Arial';
                offCtx.textAlign = 'center';
                offCtx.textBaseline = 'top';
                offCtx.strokeStyle = '#000';
                offCtx.lineWidth = 3;
                offCtx.strokeText(token.name, token.x, token.y + tokenSize + 3);
                offCtx.fillText(token.name, token.x, token.y + tokenSize + 3);
            });

            // Apply fog of war - MASK APPROACH
            const fog = currentFog || { enabled: false, radius: 150 };
            if (fog.enabled) {
                console.log('Drawing fog with mask approach...');
                
                // Restore to screen space
                offCtx.restore();
                
                if (tokens.length > 0) {
                    console.log('Creating vision mask for', tokens.length, 'tokens');
                    
                    // Create a mask canvas
                    const maskCanvas = document.createElement('canvas');
                    maskCanvas.width = canvas.width;
                    maskCanvas.height = canvas.height;
                    const maskCtx = maskCanvas.getContext('2d');
                    
                    // Fill mask with black (fog)
                    maskCtx.fillStyle = '#000000';
                    maskCtx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Apply transform to mask
                    maskCtx.translate(canvas.width / 2, canvas.height / 2);
                    maskCtx.scale(zoom, zoom);
                    maskCtx.translate(-canvas.width / 2 + panX / zoom, -canvas.height / 2 + panY / zoom);
                    
                    // Cut out vision circles using destination-out
                    maskCtx.globalCompositeOperation = 'destination-out';
                    tokens.forEach(token => {
                        console.log('Cutting circle at', token.x, token.y);
                        const gradient = maskCtx.createRadialGradient(
                            token.x, token.y, 0,
                            token.x, token.y, fog.radius
                        );
                        gradient.addColorStop(0, 'rgba(0,0,0,1)');
                        gradient.addColorStop(0.8, 'rgba(0,0,0,0.5)');
                        gradient.addColorStop(1, 'rgba(0,0,0,0)');
                        maskCtx.fillStyle = gradient;
                        maskCtx.beginPath();
                        maskCtx.arc(token.x, token.y, fog.radius, 0, Math.PI * 2);
                        maskCtx.fill();
                    });
                    
                    // Apply the mask to the main canvas
                    offCtx.globalAlpha = 0.95;
                    offCtx.drawImage(maskCanvas, 0, 0);
                    offCtx.globalAlpha = 1.0;
                    console.log('Mask applied');
                } else {
                    console.log('No tokens - drawing complete darkness');
                    offCtx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                    offCtx.fillRect(0, 0, canvas.width, canvas.height);
                }
            } else {
                console.log('Fog disabled');
                offCtx.restore();
            }
            
            // Now copy the complete offscreen canvas to the main canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(offscreen, 0, 0);
            
            console.log('Render complete');
        }
    </script>
</body>
</html>