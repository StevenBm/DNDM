<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Master View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        #controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            padding: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 100;
            flex-wrap: wrap;
            white-space: nowrap;
            overflow: visible;
        }
        button {
            background: #4a4a4a;
            color: #fff;
            border: none;
            padding: 6px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }
        button:hover {
            background: #5a5a5a;
        }
        button.active {
            background: #2a7fff;
        }
        input[type="file"], select {
            font-size: 11px;
            color: #fff;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            padding: 6px;
            border-radius: 4px;
        }
        select {
            cursor: pointer;
        }
        .dropdown-container {
            position: relative;
            display: inline-block;
        }
        .dropdown-btn {
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            color: #fff;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            min-width: 180px;
            text-align: left;
        }
        .dropdown-btn:hover {
            background: #3a3a3a;
        }
        .dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            min-width: 200px;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: visible;
            z-index: 10000;
            margin-top: 2px;
        }
        .dropdown-menu.show {
            display: block;
        }
        .dropdown-item {
            padding: 8px 32px 8px 12px;
            cursor: pointer;
            color: #fff;
            font-size: 12px;
            position: relative;
            white-space: nowrap;
        }
        .dropdown-item:hover {
            background: #3a3a3a;
        }
        .dropdown-item.has-submenu {
            position: relative;
        }
        .dropdown-item.has-submenu::after {
            content: '‚ñ∏';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
        }
        .submenu {
            display: none;
            position: fixed;
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            min-width: 200px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 10001;
        }
        .dropdown-item.has-submenu:hover .submenu {
            display: block;
        }
        input[type="text"] {
            background: #2a2a2a;
            border: 1px solid #4a4a4a;
            color: #fff;
            padding: 6px;
            border-radius: 4px;
            font-size: 12px;
            width: 120px;
        }
        #mapContainer {
            position: fixed;
            top: 45px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            background: #0a0a0a;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mapCanvas {
            display: block;
            cursor: crosshair;
            transform-origin: center center;
        }
        #mapCanvas.move-mode {
            cursor: move;
        }
        #mapCanvas.pan-mode {
            cursor: grab;
        }
        #mapCanvas.pan-mode:active {
            cursor: grabbing;
        }
        .label {
            font-size: 11px;
            color: #aaa;
            margin-left: 5px;
        }
        .status {
            color: #2a7fff;
            font-size: 11px;
            min-width: 100px;
            text-align: center;
            flex-shrink: 0;
            white-space: nowrap;
        }
        .error {
            color: #ff2a2a;
        }
        #hpEditor {
            position: fixed;
            display: none;
            z-index: 10000;
            pointer-events: auto;
            transform: translateX(-50%); /* Center horizontally */
        }
        #hpEditor.show {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }
        #hpEditor button {
            font-size: 24px;
            font-weight: bold;
            padding: 0;
            background: none;
            border: none;
            cursor: pointer;
            text-shadow: 
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000,
                2px 2px 0 #000;
            transition: transform 0.1s;
            color: #fff;
        }
        #hpEditor button:hover {
            transform: scale(1.3);
        }
        #hpEditor button:active {
            transform: scale(1.0);
        }
        #hpEditor .minus {
            color: #ff3333;
        }
        #hpEditor .plus {
            color: #33ff33;
        }
		#mapCanvas.paint-mode {
    cursor: crosshair;
}
    </style>
</head>
<body>
    <div id="controls">
        <div class="dropdown-container">
            <button class="dropdown-btn" id="mapLibraryBtn">Select Map...</button>
            <div class="dropdown-menu" id="mapLibraryMenu"></div>
        </div>
        <input type="file" id="mapUpload" accept="image/*">
        <div class="dropdown-container">
            <button class="dropdown-btn" id="playerLibraryBtn">+ Player...</button>
            <div class="dropdown-menu" id="playerLibraryMenu"></div>
        </div>
        <div class="dropdown-container">
            <button class="dropdown-btn" id="enemyLibraryBtn">+ Enemy...</button>
            <div class="dropdown-menu" id="enemyLibraryMenu"></div>
        </div>
        <div class="dropdown-container">
            <button class="dropdown-btn" id="itemLibraryBtn">+ Item...</button>
            <div class="dropdown-menu" id="itemLibraryMenu"></div>
        </div>
        <input type="text" id="tokenName" placeholder="Custom name (optional)">
        <button id="clearTokens">Clear Tokens</button>
        <span class="label">Mode:</span>
        <button id="modeMove" class="active">Move</button>
        <button id="modePlace">Place</button>
        <button id="resetZoom">Reset Zoom</button>
        <span class="status" id="status">üîÑ Connecting...</span>
<button id="toggleVisionCircles" class="active">üëÅÔ∏è Vision Circles: ON</button>
<label style="color:#fff;">Vision:</label>
<input type="range" id="visionSlider" min="50" max="400" value="150">
<button id="toggleFogLayer">üñåÔ∏è Fog Layer: OFF</button>
<button id="toggleFogPaint">‚úèÔ∏è Paint Mode</button>
<label style="color:#fff;">Brush:</label>
<input type="range" id="brushSlider" min="20" max="200" value="80">
<button id="clearFogLayer">Clear All</button>
<button id="fillFogLayer">Fill All</button>
    </div>
    <div id="mapContainer">
        <canvas id="mapCanvas"></canvas>
    </div>
    <div id="hpEditor">
        <button id="hpMinus5" class="minus">-5</button>
        <button id="hpMinus1" class="minus">-1</button>
        <button id="hpPlus1" class="plus">+1</button>
        <button id="hpPlus5" class="plus">+5</button>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        let db = null;
        let mapImage = null;
        let tokens = [];
        let selectedToken = null;
        let dragOffset = { x: 0, y: 0 };
        let mode = 'move';
        let placeType = null;
        let placeTokenName = null;
        let placeTokenImage = null;
        let playerCount = 0;
        let enemyCount = 0;
        let itemCount = 0;
        let fogEnabled = true;
        let visionRadius = 150;
		let visionCirclesEnabled = true; // Add after visionRadius
        let tokenImages = {};
        let playerLibrary = {};
        let enemyLibrary = {};
        let itemLibrary = {};
        let tokenProperties = {}; // Store properties for all tokens
        let selectedTokenForHP = null; // Track which token's HP is being edited
        let isLocalUpdate = false;
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let selectedTokens = [];
        let zoomSaveTimeout = null;
        let isSelecting = false;
        let selectionStart = { x: 0, y: 0 };
        let selectionEnd = { x: 0, y: 0 };
        let isPlacingToken = false;
		let fogCanvas = null;
		let fogCtx = null;
		let fogPaintMode = false;
		let brushSize = 80;
		let mousePos = { x: 0, y: 0 }; // ADD THIS
		let isPaintingFog = false;
		let fogLayerEnabled = false; // Add this with other variables
        const firebaseConfig = {
            apiKey: "AIzaSyBJeBvSKJucgU4UrWQVWSzexP9djl0wk0w",
            authDomain: "dnd-mapshare.firebaseapp.com",
            databaseURL: "https://dnd-mapshare-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "dnd-mapshare",
            storageBucket: "dnd-mapshare.firebasestorage.app",
            messagingSenderId: "624008039203",
            appId: "1:624008039203:web:46ee20fd32f7d8f4f95a96"
        };
		function initFogCanvas() {
    fogCanvas = document.createElement('canvas');
    fogCtx = fogCanvas.getContext('2d');
}

function resetFogCanvas() {
    if (!mapImage) return;
    fogCanvas.width = mapImage.width;
    fogCanvas.height = mapImage.height;
    fogCtx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
}

function clearFogCanvas() {
    if (!fogCanvas) return;
    fogCtx.clearRect(0, 0, fogCanvas.width, fogCanvas.height);
}

function paintFog(x, y, eraseMode) {
    if (!fogCanvas || fogCanvas.width === 0) {
        if (!mapImage) {
            statusEl.textContent = '‚ö†Ô∏è Load a map first!';
            statusEl.classList.add('error');
            setTimeout(() => {
                statusEl.textContent = '‚úì Connected to Firebase';
                statusEl.classList.remove('error');
            }, 2000);
        }
        return;
    }
    
    // FIXED: Use destination-out to REMOVE fog (reveal), source-over to ADD fog (hide)
    fogCtx.globalCompositeOperation = eraseMode ? 'source-over' : 'destination-out';
    
    const gradient = fogCtx.createRadialGradient(x, y, 0, x, y, brushSize);
    if (eraseMode) {
        // Adding fog back (hiding)
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0.85)');
        gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.4)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        statusEl.textContent = 'üñåÔ∏è Hiding area...';
    } else {
        // Removing fog (revealing)
        gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
        gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.5)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        statusEl.textContent = '‚úèÔ∏è Revealing area...';
    }
    
    fogCtx.fillStyle = gradient;
    fogCtx.beginPath();
    fogCtx.arc(x, y, brushSize, 0, Math.PI * 2);
    fogCtx.fill();
    
    fogCtx.globalCompositeOperation = 'source-over';
    
    renderMap();
}
        try {
            const app = initializeApp(firebaseConfig);
            db = getDatabase(app);
            statusEl.textContent = '‚úì Connected to Firebase';
            loadState();
			initFogCanvas(); // ADD THIS LINE
			fogLayerEnabled = true;
			document.getElementById('toggleFogLayer').classList.add('active');
			document.getElementById('toggleFogLayer').textContent = 'üñåÔ∏è Fog Layer: ON';
        } catch (e) {
            statusEl.textContent = '‚úó Firebase connection failed';
            statusEl.classList.add('error');
            console.error('Firebase init error:', e);
        }

        let mapLibrary = {};
		
        async function scanMapsFolder() {
            try {
                const repoOwner = 'StevenBm';
                const repoName = 'DNDM';
                const branch = 'main';
                
                const response = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/git/trees/${branch}?recursive=1`);
                const data = await response.json();
                
                if (data.tree) {
                    const mapFiles = data.tree.filter(item => 
                        item.path.startsWith('maps/') && 
                        item.type === 'blob' &&
                        /\.(jpg|jpeg|png|gif|webp)$/i.test(item.path)
                    );
                    
                    mapLibrary = {};
                    mapFiles.forEach(file => {
                        const parts = file.path.split('/');
                        const pathParts = parts.slice(1, -1);
                        const filename = parts[parts.length - 1];
                        const mapName = filename.replace(/\.(jpg|jpeg|png|gif|webp)$/i, '')
                            .replace(/[-_]/g, ' ')
                            .replace(/\b\w/g, l => l.toUpperCase());
                        
                        let current = mapLibrary;
                        pathParts.forEach((part, index) => {
                            const displayName = part.replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                            if (index === pathParts.length - 1) {
                                if (!current[displayName]) current[displayName] = {};
                                current[displayName][mapName] = file.path;
                            } else {
                                if (!current[displayName]) current[displayName] = {};
                                current = current[displayName];
                            }
                        });
                    });
                    
                    buildMapDropdown();
                }
            } catch (e) {
                console.error('Failed to scan maps folder:', e);
            }
        }

        function buildMapDropdown() {
            const menu = document.getElementById('mapLibraryMenu');
            menu.innerHTML = '';
            
            function createMenuItems(obj, container) {
                for (const [key, value] of Object.entries(obj)) {
                    const item = document.createElement('div');
                    item.className = 'dropdown-item';
                    
                    if (typeof value === 'string') {
                        item.textContent = key;
                        item.addEventListener('click', () => {
                            loadMapFromUrl(value);
                            closeAllDropdowns();
                        });
                    } else if (typeof value === 'object' && value !== null) {
                        item.textContent = key;
                        item.classList.add('has-submenu');
                        
                        const submenu = document.createElement('div');
                        submenu.className = 'submenu';
                        createMenuItems(value, submenu);
                        item.appendChild(submenu);
                        
                        item.addEventListener('mouseenter', () => {
                            const rect = item.getBoundingClientRect();
                            submenu.style.left = rect.right + 'px';
                            submenu.style.top = rect.top + 'px';
                        });
                    }
                    
                    container.appendChild(item);
                }
            }
            
            createMenuItems(mapLibrary, menu);
        }

        document.getElementById('mapLibraryBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            closeAllDropdowns();
            const menu = document.getElementById('mapLibraryMenu');
            menu.classList.toggle('show');
        });

        scanMapsFolder();
        scanTokenFolders();

        function loadMapFromUrl(url) {
            const img = new Image();
            fogEnabled = true;
		 document.getElementById('toggleFogLayer').classList.add('active');
        document.getElementById('toggleFogLayer').textContent = 'üñåÔ∏è Fog Layer: ON';
            img.onload = () => {
                mapImage = img;
                canvas.width = img.width;
                canvas.height = img.height;
                zoom = 1;
                panX = 0;
                panY = 0;
				resetFogCanvas(); // ADD THIS LINE
				fogLayerEnabled = true; // ADD THIS
		 document.getElementById('toggleFogLayer').classList.add('active');
        document.getElementById('toggleFogLayer').textContent = 'üñåÔ∏è Fog Layer: ON';
                renderMap();
                saveState();
            };
            img.onerror = () => {
                alert('Failed to load map from: ' + url);
            };
            img.src = url;
        }

        function loadState() {
            if (!db) return;
            const stateRef = ref(db, 'gameState');
            onValue(stateRef, (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    console.log('=== FIREBASE UPDATE RECEIVED ===');
                    console.log('isLocalUpdate flag:', isLocalUpdate);
                    console.log('Current tokens length:', tokens.length);
                    console.log('Incoming tokens length:', data.tokens?.length);
                    
                    if (isLocalUpdate) {
                        console.log('Ignoring - was local change');
                        isLocalUpdate = false;
                        return;
                    }
                    
                    if (data.mapData && (!mapImage || canvas.toDataURL('image/jpeg', 0.7) !== data.mapData)) {
                        const img = new Image();
                        img.onload = () => {
                            mapImage = img;
                            canvas.width = img.width;
                            canvas.height = img.height;
                            renderMap();
                        };
                        img.src = data.mapData;
                    }
                    
                    if (!zoomSaveTimeout && !isPanning && !isSelecting && selectedTokens.length === 0 && !isPlacingToken && !saveTimeout) {
                        if (data.zoom !== undefined && data.pan) {
                            zoom = data.zoom;
                            panX = data.pan.x;
                            panY = data.pan.y;
                            renderMap();
                        }
                    }
                    
                    if (data.tokens) {
                        console.log('Replacing tokens from Firebase');
                        console.log('Current tokens.length:', tokens.length);
                        console.log('Incoming tokens.length:', data.tokens.length);
                        console.log('Incoming tokens:', JSON.stringify(data.tokens.map(t => ({name: t.name, x: Math.round(t.x), y: Math.round(t.y)}))));
                        
                        tokens = data.tokens;
                        
                        console.log('After replacement - tokens.length:', tokens.length);
                        
                        playerCount = tokens.filter(t => t.type === 'player').length;
                        enemyCount = tokens.filter(t => t.type === 'enemy').length;
                        itemCount = tokens.filter(t => t.type === 'item').length;
                        
                        tokens.forEach(token => {
                            if (token.image && !tokenImages[token.image]) {
                                loadTokenImage(token.image);
                            }
                        });
if (data.fogLayerEnabled !== undefined) {
    fogLayerEnabled = data.fogLayerEnabled;
    const btn = document.getElementById('toggleFogLayer');
    btn.textContent = fogLayerEnabled ? 'üñåÔ∏è Fog Layer: ON' : 'üñåÔ∏è Fog Layer: OFF';
    btn.classList.toggle('active', fogLayerEnabled);
}

if (data.fogLayer) {
    const img = new Image();
    img.onload = () => {
        if (!fogCanvas || fogCanvas.width !== img.width || fogCanvas.height !== img.height) {
            fogCanvas.width = img.width;
            fogCanvas.height = img.height;
        }
        fogCtx.clearRect(0, 0, fogCanvas.width, fogCanvas.height);
        fogCtx.drawImage(img, 0, 0);
        renderMap();
    };
    img.src = data.fogLayer;
}
                        if (mapImage) {
                            renderMap();
                        }
                    }
                }
            });
        }

        let saveTimeout = null;

        async function saveState() {
            if (!db) return;
            
            console.log('=== SAVE CALLED ===');
            console.log('Tokens to save:', tokens.length);
            
            isLocalUpdate = true;
            
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            saveTimeout = setTimeout(async () => {
                // CRITICAL: Save the ORIGINAL map image, not the rendered canvas
                let mapData = null;
                if (mapImage) {
                    // Create a temporary canvas with just the map
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = mapImage.width;
                    tempCanvas.height = mapImage.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(mapImage, 0, 0);
                    mapData = tempCanvas.toDataURL('image/jpeg', 0.7);
                }
                
                const state = {
                    mapData: mapData,
                    tokens: tokens,
                    fog: {
                        enabled: fogEnabled,
                        radius: visionRadius
                    },
					fogLayer: fogCanvas && fogCanvas.width > 0 ? fogCanvas.toDataURL('image/png') : null, // ADD THIS
					 fogLayerEnabled: fogLayerEnabled, // ADD THIS
                    zoom: zoom,
                    pan: { x: panX, y: panY },
                    timestamp: Date.now()
                };
                
                console.log('Saving tokens:', state.tokens.length);
                
                try {
                    await set(ref(db, 'gameState'), state);
                    statusEl.textContent = '‚úì Synced';
                    console.log('Save complete');
                    setTimeout(() => {
                        statusEl.textContent = '‚úì Connected to Firebase';
                    }, 1000);
                } catch (e) {
                    statusEl.textContent = '‚úó Sync failed';
                    statusEl.classList.add('error');
                    console.error('Save error:', e);
                }
            }, 200);
        }

        document.getElementById('mapUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        mapImage = img;
                        canvas.width = img.width;
                        canvas.height = img.height;
                        zoom = 1;
                        panX = 0;
                        panY = 0;
						resetFogCanvas(); // ADD THIS LINE
						 fogLayerEnabled = true; // ADD THIS
						document.getElementById('toggleFogLayer').classList.add('active'); // ADD THIS
						document.getElementById('toggleFogLayer').textContent = 'üñåÔ∏è Fog Layer: ON'; // ADD THIS
                        renderMap();
                        saveState();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        function renderMap() {
            // STEP 1: Nuclear clear - ensure nothing persists
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.globalCompositeOperation = 'source-over';
            
            // Clear and fill with background color
            ctx.clearRect(0, 0, w, h);
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, w, h);
            
            // STEP 2: Apply transform
            ctx.translate(w / 2, h / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-w / 2 + panX / zoom, -h / 2 + panY / zoom);
            
            // STEP 3: Draw map
            if (mapImage) {
                ctx.drawImage(mapImage, 0, 0);
            }
			if (fogLayerEnabled && fogCanvas && fogCanvas.width > 0) {
				ctx.save();
    ctx.globalAlpha = 0.6; // ADD THIS - makes fog 60% opaque (40% transparent)
    ctx.drawImage(fogCanvas, 0, 0);
    ctx.restore(); // ADD THIS
			}
            // STEP 4: Draw tokens
            renderTokens();
			if (visionCirclesEnabled) {
				const playerTokens = tokens.filter(t => t.type === 'player');
				playerTokens.forEach(token => {
					ctx.beginPath();
					ctx.arc(token.x, token.y, visionRadius, 0, Math.PI * 2);
					ctx.strokeStyle = 'rgba(42, 127, 255, 0.3)';
					ctx.lineWidth = 2 / zoom;
					ctx.setLineDash([10 / zoom, 10 / zoom]);
					ctx.stroke();
					ctx.setLineDash([]);
				});
			}
								if (fogEnabled) {
			const playerTokens = tokens.filter(t => t.type === 'player');
			playerTokens.forEach(token => {
				ctx.beginPath();
				ctx.arc(token.x, token.y, visionRadius, 0, Math.PI * 2);
				ctx.strokeStyle = 'rgba(42, 127, 255, 0.3)';
				ctx.lineWidth = 2 / zoom;
				ctx.setLineDash([10 / zoom, 10 / zoom]);
				ctx.stroke();
				ctx.setLineDash([]);
			});
		}
            // STEP 5: Draw selection box
            if (isSelecting && selectionStart.x !== undefined) {
                ctx.strokeStyle = '#2a7fff';
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([5 / zoom, 5 / zoom]);
                ctx.fillStyle = 'rgba(42, 127, 255, 0.1)';
                
                const x1 = selectionStart.x;
                const y1 = selectionStart.y;
                const x2 = selectionEnd.x;
                const y2 = selectionEnd.y;
                
                const x = Math.min(x1, x2);
                const y = Math.min(y1, y2);
                const width = Math.abs(x2 - x1);
                const height = Math.abs(y2 - y1);
                
                ctx.fillRect(x, y, width, height);
                ctx.strokeRect(x, y, width, height);
                ctx.setLineDash([]);
            }
             if (mode === 'fogpaint' && mousePos.x !== undefined) {
        ctx.beginPath();
        ctx.arc(mousePos.x, mousePos.y, brushSize, 0, Math.PI * 2);
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2 / zoom;
        ctx.setLineDash([5 / zoom, 5 / zoom]);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw crosshair in center
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 1 / zoom;
        ctx.beginPath();
        ctx.moveTo(mousePos.x - 10 / zoom, mousePos.y);
        ctx.lineTo(mousePos.x + 10 / zoom, mousePos.y);
        ctx.moveTo(mousePos.x, mousePos.y - 10 / zoom);
        ctx.lineTo(mousePos.x, mousePos.y + 10 / zoom);
        ctx.stroke();
    }
            // STEP 6: Reset transform
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        function renderTokens() {
            console.log('=== RENDERING TOKENS ===');
            console.log('tokens.length:', tokens.length);
            console.log('tokens array:', tokens.map(t => ({name: t.name, x: Math.round(t.x), y: Math.round(t.y)})));
            
            let renderCount = 0;
            tokens.forEach(token => {
                renderCount++;
                console.log(`Rendering token #${renderCount}:`, token.name, 'at', Math.round(token.x), Math.round(token.y));
                
                const tokenSize = (token.size || 1) * 20; // Base size 20, multiply by size modifier
                
                if (token.image && tokenImages[token.image]) {
                    const img = tokenImages[token.image];
                    ctx.save();
                    
                    ctx.beginPath();
                    ctx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.clip();
                    
                    const imageSize = tokenSize * 2;
                    ctx.drawImage(img, token.x - tokenSize, token.y - tokenSize, imageSize, imageSize);
                    
                    ctx.restore();
                    
                    ctx.beginPath();
                    ctx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
                    if (token.type === 'player') {
                        ctx.strokeStyle = '#2a7fff';
                    } else if (token.type === 'enemy') {
                        ctx.strokeStyle = '#ff2a2a';
                    } else if (token.type === 'item') {
                        ctx.strokeStyle = '#ffaa00';
                    }
                    ctx.lineWidth = 3;
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(token.x, token.y, tokenSize, 0, Math.PI * 2);
                    if (token.type === 'player') {
                        ctx.fillStyle = 'rgba(42, 127, 255, 0.8)';
                        ctx.strokeStyle = '#2a7fff';
                    } else if (token.type === 'enemy') {
                        ctx.fillStyle = 'rgba(255, 42, 42, 0.8)';
                        ctx.strokeStyle = '#ff2a2a';
                    } else if (token.type === 'item') {
                        ctx.fillStyle = 'rgba(255, 170, 0, 0.8)';
                        ctx.strokeStyle = '#ffaa00';
                    }
                    ctx.fill();
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Draw name
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(token.name, token.x, token.y + tokenSize + 3);
                ctx.fillText(token.name, token.x, token.y + tokenSize + 3);
                
                // Draw HP for players and enemies
                if ((token.type === 'player' || token.type === 'enemy') && token.hp !== undefined) {
                    const hpText = `${token.hp}${token.maxHp ? '/' + token.maxHp : ''}`;
                    
                    // Draw HP background box
                    ctx.font = 'bold 14px Arial';
                    const metrics = ctx.measureText(hpText);
                    const boxWidth = metrics.width + 8;
                    const boxHeight = 20;
                    const boxX = token.x - boxWidth / 2;
                    const boxY = token.y - tokenSize - boxHeight - 5;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                    ctx.strokeStyle = token.type === 'player' ? '#2a7fff' : '#ff2a2a';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                    
                    // Draw HP text
                    ctx.fillStyle = '#fff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(hpText, token.x, boxY + boxHeight / 2);
                }
            });

            selectedTokens.forEach(token => {
                const tokenSize = (token.size || 1) * 20;
                ctx.beginPath();
                ctx.arc(token.x, token.y, tokenSize + 5, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            });
            
            console.log(`Total tokens rendered: ${renderCount}`);
        }

        function loadTokenImage(imagePath) {
            if (!tokenImages[imagePath]) {
                const img = new Image();
                img.onload = () => {
                    tokenImages[imagePath] = img;
                    renderMap();
                };
                img.onerror = () => {
                    console.error('Failed to load token image:', imagePath);
                };
                img.src = imagePath;
            }
        }

        async function scanTokenFolders() {
            try {
                const repoOwner = 'StevenBm';
                const repoName = 'DNDM';
                const branch = 'main';
                
                const response = await fetch(`https://api.github.com/repos/${repoOwner}/${repoName}/git/trees/${branch}?recursive=1`);
                const data = await response.json();
                
                if (data.tree) {
                    // Load properties files first
                    const propertiesFiles = data.tree.filter(item => 
                        item.path.endsWith('properties.json')
                    );
                    
                    for (const propFile of propertiesFiles) {
                        try {
                            const propResponse = await fetch(`https://raw.githubusercontent.com/${repoOwner}/${repoName}/${branch}/${propFile.path}`);
                            const properties = await propResponse.json();
                            
                            // Store properties by folder
                            const folder = propFile.path.split('/')[0];
                            if (!tokenProperties[folder]) tokenProperties[folder] = {};
                            Object.assign(tokenProperties[folder], properties);
                            console.log(`Loaded properties for ${folder}:`, properties);
                        } catch (e) {
                            console.warn(`Failed to load properties from ${propFile.path}:`, e);
                        }
                    }
                    
                    const playerFiles = data.tree.filter(item => 
                        item.path.startsWith('players/') && 
                        item.type === 'blob' &&
                        /\.(jpg|jpeg|png|gif|webp)$/i.test(item.path)
                    );
                    
                    const enemyFiles = data.tree.filter(item => 
                        item.path.startsWith('enemies/') && 
                        item.type === 'blob' &&
                        /\.(jpg|jpeg|png|gif|webp)$/i.test(item.path)
                    );
                    
                    const itemFiles = data.tree.filter(item => 
                        item.path.startsWith('items/') && 
                        item.type === 'blob' &&
                        /\.(jpg|jpeg|png|gif|webp)$/i.test(item.path)
                    );
                    
                    playerLibrary = buildTokenLibrary(playerFiles, 'players/');
                    enemyLibrary = buildTokenLibrary(enemyFiles, 'enemies/');
                    itemLibrary = buildTokenLibrary(itemFiles, 'items/');
                    
                    buildTokenDropdowns();
                }
            } catch (e) {
                console.error('Failed to scan token folders:', e);
            }
        }

        function buildTokenLibrary(files, prefix) {
            const library = {};
            files.forEach(file => {
                const parts = file.path.split('/');
                const pathParts = parts.slice(1, -1);
                const filename = parts[parts.length - 1];
                const tokenName = filename.replace(/\.(jpg|jpeg|png|gif|webp)$/i, '')
                    .replace(/[-_]/g, ' ')
                    .replace(/\b\w/g, l => l.toUpperCase());
                
                let current = library;
                pathParts.forEach((part, index) => {
                    const displayName = part.replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    if (index === pathParts.length - 1) {
                        if (!current[displayName]) current[displayName] = {};
                        current[displayName][tokenName] = file.path;
                    } else {
                        if (!current[displayName]) current[displayName] = {};
                        current = current[displayName];
                    }
                });
                
                if (pathParts.length === 0) {
                    library[tokenName] = file.path;
                }
            });
            return library;
        }

        function buildTokenDropdowns() {
            buildTokenDropdown('playerLibraryMenu', playerLibrary, 'player');
            buildTokenDropdown('enemyLibraryMenu', enemyLibrary, 'enemy');
            buildTokenDropdown('itemLibraryMenu', itemLibrary, 'item');
        }

        function buildTokenDropdown(menuId, library, tokenType) {
            const menu = document.getElementById(menuId);
            menu.innerHTML = '';
            
            function createMenuItems(obj, container) {
                for (const [key, value] of Object.entries(obj)) {
                    const item = document.createElement('div');
                    item.className = 'dropdown-item';
                    
                    if (typeof value === 'string') {
                        item.textContent = key;
                        item.addEventListener('click', () => {
                            placeTokenFromLibrary(tokenType, key, value);
                            closeAllDropdowns();
                        });
                    } else if (typeof value === 'object' && value !== null) {
                        item.textContent = key;
                        item.classList.add('has-submenu');
                        
                        const submenu = document.createElement('div');
                        submenu.className = 'submenu';
                        createMenuItems(value, submenu);
                        item.appendChild(submenu);
                        
                        item.addEventListener('mouseenter', () => {
                            const rect = item.getBoundingClientRect();
                            submenu.style.left = rect.right + 'px';
                            submenu.style.top = rect.top + 'px';
                        });
                    }
                    
                    container.appendChild(item);
                }
            }
            
            createMenuItems(library, menu);
        }

        function screenToCanvas(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const canvasX = screenX - rect.left;
            const canvasY = screenY - rect.top;
            const centerX = canvasX - rect.width / 2;
            const centerY = canvasY - rect.height / 2;
            const worldX = (centerX - panX) / zoom + canvas.width / 2;
            const worldY = (centerY - panY) / zoom + canvas.height / 2;
            return { x: worldX, y: worldY };
        }

        function placeTokenFromLibrary(type, defaultName, imagePath) {
            mode = 'place';
            placeType = type;
            placeTokenName = document.getElementById('tokenName').value || defaultName;
            placeTokenImage = imagePath;
            
            loadTokenImage(imagePath);
            
            canvas.classList.remove('move-mode');
            canvas.classList.remove('pan-mode');
            document.getElementById('modePlace').classList.add('active');
            document.getElementById('modeMove').classList.remove('active');
        }

        document.getElementById('playerLibraryBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            closeAllDropdowns();
            document.getElementById('playerLibraryMenu').classList.toggle('show');
        });

        document.getElementById('enemyLibraryBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            closeAllDropdowns();
            document.getElementById('enemyLibraryMenu').classList.toggle('show');
        });

        document.getElementById('itemLibraryBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            closeAllDropdowns();
            document.getElementById('itemLibraryMenu').classList.toggle('show');
        });

        function closeAllDropdowns() {
            document.querySelectorAll('.dropdown-menu').forEach(menu => {
                menu.classList.remove('show');
            });
        }

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.dropdown-container')) {
                closeAllDropdowns();
            }
        });

        document.getElementById('modeMove').addEventListener('click', () => {
            mode = 'move';
            placeType = null;
            canvas.classList.remove('crosshair');
            canvas.classList.remove('pan-mode');
            canvas.classList.add('move-mode');
            document.getElementById('modeMove').classList.add('active');
            document.getElementById('modePlace').classList.remove('active');
            selectedTokens = [];
            renderMap();
        });

        document.getElementById('modePlace').addEventListener('click', () => {
            mode = 'place';
            canvas.classList.remove('move-mode');
            canvas.classList.remove('pan-mode');
            document.getElementById('modeMove').classList.remove('active');
            document.getElementById('modePlace').classList.add('active');
            selectedTokens = [];
            renderMap();
        });
document.getElementById('visionSlider').addEventListener('input', (e) => {
    visionRadius = parseInt(e.target.value);
    renderMap();
    saveState();
});

document.getElementById('brushSlider').addEventListener('input', (e) => {
    brushSize = parseInt(e.target.value);
});

// Toggle fog layer visibility (separate from vision circles)
document.getElementById('toggleFogLayer').addEventListener('click', () => {
    fogLayerEnabled = !fogLayerEnabled;
    const btn = document.getElementById('toggleFogLayer');
    btn.textContent = fogLayerEnabled ? 'üñåÔ∏è Fog Layer: ON' : 'üñåÔ∏è Fog Layer: OFF';
    btn.classList.toggle('active', fogLayerEnabled);
    renderMap();
    saveState();
});

// Toggle paint mode
document.getElementById('toggleFogPaint').addEventListener('click', () => {
    fogPaintMode = !fogPaintMode;
    const btn = document.getElementById('toggleFogPaint');
    btn.classList.toggle('active', fogPaintMode);
    
    if (fogPaintMode) {
        mode = 'fogpaint';
        canvas.classList.add('paint-mode');
        canvas.classList.remove('move-mode');
        canvas.classList.remove('pan-mode');
        document.getElementById('modeMove').classList.remove('active');
        document.getElementById('modePlace').classList.remove('active');
        statusEl.textContent = 'üñåÔ∏è Paint Mode: Left-click to reveal, Ctrl+click to hide';
    } else {
        mode = 'move';
        canvas.classList.remove('paint-mode');
        canvas.classList.add('move-mode');
        document.getElementById('modeMove').classList.add('active');
        statusEl.textContent = '‚úì Connected to Firebase';
    }
});

document.getElementById('clearFogLayer').addEventListener('click', () => {
    clearFogCanvas();
    renderMap();
    saveState();
});

document.getElementById('fillFogLayer').addEventListener('click', () => {
    resetFogCanvas();
    renderMap();
    saveState();
});

document.getElementById('toggleVisionCircles').addEventListener('click', () => {
    visionCirclesEnabled = !visionCirclesEnabled;
    const btn = document.getElementById('toggleVisionCircles');
    btn.textContent = visionCirclesEnabled ? 'üëÅÔ∏è Vision Circles: ON' : 'üëÅÔ∏è Vision Circles: OFF';
    btn.classList.toggle('active', visionCirclesEnabled);
    renderMap();
});

        document.getElementById('resetZoom').addEventListener('click', () => {
            zoom = 1;
            panX = 0;
            panY = 0;
            renderMap();
            saveState();
        });

        canvas.addEventListener("wheel", (e) => {
            e.preventDefault();

            // Close HP editor when zooming
            if (selectedTokenForHP) {
                document.getElementById('hpEditor').classList.remove('show');
                selectedTokenForHP = null;
            }

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left - rect.width / 2;
            const mouseY = e.clientY - rect.top - rect.height / 2;
            const worldX = (mouseX - panX) / zoom + canvas.width / 2;
            const worldY = (mouseY - panY) / zoom + canvas.height / 2;

            const scaleBy = 1.2;
            let direction = e.deltaY > 0 ? -1 : 1;
            
            zoom = direction > 0 ? zoom * scaleBy : zoom / scaleBy;
            zoom = Math.min(Math.max(zoom, 0.2), 8);

            panX = mouseX - (worldX - canvas.width / 2) * zoom;
            panY = mouseY - (worldY - canvas.height / 2) * zoom;

            renderMap();

            clearTimeout(zoomSaveTimeout);
            zoomSaveTimeout = setTimeout(() => saveState(), 300);
        }, { passive: false });

        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 1) {
                e.preventDefault();
            }
            
            // Close HP editor if open
            if (selectedTokenForHP) {
                document.getElementById('hpEditor').classList.remove('show');
                selectedTokenForHP = null;
            }
            
            if (e.button === 1 || (e.shiftKey && e.button === 0)) {
                // Close HP editor when panning
                if (selectedTokenForHP) {
                    document.getElementById('hpEditor').classList.remove('show');
                    selectedTokenForHP = null;
                }
                
                isPanning = true;
                canvas.classList.add('pan-mode');
                panStart = { x: e.clientX, y: e.clientY };
                e.preventDefault();
                return;
            }
            
            if (e.button !== 0 || e.shiftKey) return;
            
            const pos = screenToCanvas(e.clientX, e.clientY);
            const x = pos.x;
            const y = pos.y;
            
            console.log('CLICK - World:', x, y);
if (mode === 'fogpaint') {
    isPaintingFog = true;
    paintFog(x, y, e.ctrlKey || e.metaKey);
    return;
}

            if (mode === 'place' && placeType) {
                isPlacingToken = true;
                
                let name;
                const customName = document.getElementById('tokenName').value;
                
                if (customName) {
                    name = customName;
                } else if (placeTokenName) {
                    name = placeTokenName;
                } else {
                    if (placeType === 'player') name = 'P' + (++playerCount);
                    else if (placeType === 'enemy') name = 'E' + (++enemyCount);
                    else if (placeType === 'item') name = 'I' + (++itemCount);
                }
                
                const newToken = { 
                    x, 
                    y, 
                    type: placeType, 
                    name: name
                };
                
                if (placeTokenImage) {
                    newToken.image = placeTokenImage;
                }
                
                // Add properties from JSON if available
                const folder = placeType === 'player' ? 'players' : placeType === 'enemy' ? 'enemies' : 'items';
                if (tokenProperties[folder] && tokenProperties[folder][name]) {
                    const props = tokenProperties[folder][name];
                    if (props.size !== undefined) newToken.size = props.size;
                    if (props.hp !== undefined) newToken.hp = props.hp;
                    if (props.maxHp !== undefined) newToken.maxHp = props.maxHp;
                    console.log('Applied properties for', name, ':', props);
                } else {
                    console.log('No properties found for', name, 'in folder', folder);
                }
                
                // Set default size if not specified
                if (newToken.size === undefined) newToken.size = 1;
                
                console.log('=== PLACING ===');
                console.log('Before push - tokens array:', JSON.stringify(tokens.map(t => ({name: t.name, x: Math.round(t.x), y: Math.round(t.y)}))));
                console.log('Before push - tokens.length:', tokens.length);
                
                tokens.push(newToken);
                
                console.log('After push - tokens.length:', tokens.length);
                console.log('After push - tokens array:', JSON.stringify(tokens.map(t => ({name: t.name, x: Math.round(t.x), y: Math.round(t.y)}))));
                console.log('New token:', JSON.stringify({name: newToken.name, x: Math.round(newToken.x), y: Math.round(newToken.y)}));
                
                document.getElementById('tokenName').value = '';
                
                renderMap();
                saveState();
                
                setTimeout(() => {
                    isPlacingToken = false;
                }, 500);
                
            } else if (mode === 'move') {
                const clickedToken = tokens.find(t => {
                    const tokenSize = (t.size || 1) * 20;
                    return Math.sqrt((t.x - x) ** 2 + (t.y - y) ** 2) < tokenSize;
                });
                
                if (clickedToken && (e.ctrlKey || e.metaKey)) {
                    const index = selectedTokens.indexOf(clickedToken);
                    if (index === -1) {
                        selectedTokens.push(clickedToken);
                    } else {
                        selectedTokens.splice(index, 1);
                    }
                    renderMap();
                } else if (clickedToken && selectedTokens.includes(clickedToken)) {
                    selectedTokens.forEach(t => {
                        t.dragOffset = { x: x - t.x, y: y - t.y };
                    });
                } else if (clickedToken) {
                    selectedTokens = [clickedToken];
                    clickedToken.dragOffset = { x: x - clickedToken.x, y: y - clickedToken.y };
                    renderMap();
                } else {
                    selectedTokens = [];
                    isSelecting = true;
                    selectionStart = { x: x, y: y };
                    selectionEnd = { x: x, y: y };
                    renderMap();
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
                const pos = screenToCanvas(e.clientX, e.clientY);
				mousePos = pos;
			if (isPanning) {
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                panX += dx;
                panY += dy;
                panStart = { x: e.clientX, y: e.clientY };
                renderMap();
                return;
            }
if (isPaintingFog && mode === 'fogpaint') {
    const pos = screenToCanvas(e.clientX, e.clientY);
    paintFog(pos.x, pos.y, e.ctrlKey || e.metaKey);
    return;
}
  if (mode === 'fogpaint') {
        renderMap(); // Redraw to show brush preview
    }
            if (isSelecting) {
                const pos = screenToCanvas(e.clientX, e.clientY);
                selectionEnd.x = pos.x;
                selectionEnd.y = pos.y;
                renderMap();
                return;
            }

            if (selectedTokens.length > 0 && mode === 'move') {
                const pos = screenToCanvas(e.clientX, e.clientY);
                const x = pos.x;
                const y = pos.y;
                
                selectedTokens.forEach(token => {
                    if (token.dragOffset) {
                        token.x = x - token.dragOffset.x;
                        token.y = y - token.dragOffset.y;
                    }
                });
                renderMap();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvas.classList.remove('pan-mode');
                saveState();
                return;
            }
if (isPaintingFog) {
    isPaintingFog = false;
    statusEl.textContent = 'üíæ Saving...';
    saveState();
    setTimeout(() => {
        statusEl.textContent = '‚úì Connected to Firebase';
    }, 1000);
    return;
}
            
            if (isSelecting) {
                isSelecting = false;
                
                const x1 = selectionStart.x;
                const y1 = selectionStart.y;
                const x2 = selectionEnd.x;
                const y2 = selectionEnd.y;
                
                selectedTokens = tokens.filter(t => 
                    t.x >= Math.min(x1, x2) && t.x <= Math.max(x1, x2) &&
                    t.y >= Math.min(y1, y2) && t.y <= Math.max(y1, y2)
                );
                
                renderMap();
                return;
            }
            
            if (selectedTokens.length > 0) {
                selectedTokens.forEach(t => delete t.dragOffset);
                saveState();
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                canvas.classList.remove('pan-mode');
                saveState();
            }
if (isPaintingFog) {
    isPaintingFog = false;
    statusEl.textContent = 'üíæ Saving...';
    saveState();
    setTimeout(() => {
        statusEl.textContent = '‚úì Connected to Firebase';
    }, 1000);
}
            if (selectedTokens.length > 0) {
                selectedTokens.forEach(t => delete t.dragOffset);
                saveState();
            }
        });

        document.getElementById('clearTokens').addEventListener('click', () => {
            tokens = [];
            selectedTokens = [];
            playerCount = 0;
            enemyCount = 0;
            itemCount = 0;
            renderMap();
            saveState();
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            
            // If HP editor is already open, close it first
            if (selectedTokenForHP) {
                document.getElementById('hpEditor').classList.remove('show');
                selectedTokenForHP = null;
                return;
            }
            
            const pos = screenToCanvas(e.clientX, e.clientY);
            const x = pos.x;
            const y = pos.y;
            
            // Check if clicking on a token with HP
            const clickedToken = tokens.find(t => {
                const tokenSize = (t.size || 1) * 20;
                return Math.sqrt((t.x - x) ** 2 + (t.y - y) ** 2) < tokenSize;
            });
            
            if (clickedToken && (clickedToken.type === 'player' || clickedToken.type === 'enemy') && clickedToken.hp !== undefined) {
                // Show HP editor
                selectedTokenForHP = clickedToken;
                const hpEditor = document.getElementById('hpEditor');
                
                // Calculate initial position
                const rect = canvas.getBoundingClientRect();
                const tokenSize = (clickedToken.size || 1) * 20;
                
                // Convert world coordinates to screen coordinates
                const screenX = rect.left + rect.width / 2 + (clickedToken.x - canvas.width / 2) * zoom + panX;
                const screenY = rect.top + rect.height / 2 + (clickedToken.y - canvas.height / 2) * zoom + panY;
                
                // Calculate HP box position (same as rendering logic)
                const hpBoxY = screenY - tokenSize * zoom - 20 * zoom - 5;
                
                // Position buttons centered above HP box (using CSS transform: translateX(-50%))
                hpEditor.style.left = screenX + 'px';
                hpEditor.style.top = (hpBoxY - 35) + 'px';
                hpEditor.classList.add('show');
                
                return;
            }
            
            // If no HP token clicked, do normal deletion
            const clickedSelectedToken = selectedTokens.find(t => {
                const tokenSize = (t.size || 1) * 20;
                return Math.sqrt((t.x - x) ** 2 + (t.y - y) ** 2) < tokenSize;
            });
            
            if (clickedSelectedToken && selectedTokens.length > 1) {
                tokens = tokens.filter(t => !selectedTokens.includes(t));
                selectedTokens = [];
                renderMap();
                saveState();
            } else {
                const index = tokens.findIndex(t => {
                    const tSize = (t.size || 1) * 20;
                    return Math.sqrt((t.x - x) ** 2 + (t.y - y) ** 2) < tSize;
                });
                if (index !== -1) {
                    const deletedToken = tokens[index];
                    tokens.splice(index, 1);
                    
                    const selectedIndex = selectedTokens.indexOf(deletedToken);
                    if (selectedIndex !== -1) {
                        selectedTokens.splice(selectedIndex, 1);
                    }
                    
                    renderMap();
                    saveState();
                }
            }
        });

        // HP Editor controls
        document.getElementById('hpMinus5').addEventListener('click', () => modifyHP(-5));
        document.getElementById('hpMinus1').addEventListener('click', () => modifyHP(-1));
        document.getElementById('hpPlus1').addEventListener('click', () => modifyHP(1));
        document.getElementById('hpPlus5').addEventListener('click', () => modifyHP(5));

        function modifyHP(amount) {
            if (!selectedTokenForHP) return;
            
            selectedTokenForHP.hp = Math.max(0, selectedTokenForHP.hp + amount);
            if (selectedTokenForHP.maxHp) {
                selectedTokenForHP.hp = Math.min(selectedTokenForHP.maxHp, selectedTokenForHP.hp);
            }
            
            renderMap();
            saveState();
        }

        // Close HP editor when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#hpEditor') && !e.target.closest('#mapCanvas')) {
                document.getElementById('hpEditor').classList.remove('show');
                selectedTokenForHP = null;
            }
        });

        // Delete key to remove selected tokens
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' && selectedTokens.length > 0) {
                tokens = tokens.filter(t => !selectedTokens.includes(t));
                selectedTokens = [];
                renderMap();
                saveState();
            }
        });

        canvas.classList.add('move-mode');
    </script>
</body>
</html>