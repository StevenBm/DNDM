<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Player View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            padding: 6px 12px;
            z-index: 100;
            text-align: center;
            font-size: 12px;
        }
        #mapContainer {
            position: fixed;
            top: 30px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mapCanvas {
            display: block;
            transform-origin: center center;
        }
        .status {
            color: #2a7fff;
        }
        .waiting {
            color: #ff9500;
        }
        .error {
            color: #ff2a2a;
        }
    </style>
</head>
<body>
    <div id="header">
        <span class="status waiting" id="status">⏳ Connecting...</span>
    </div>
    <div id="mapContainer">
        <canvas id="mapCanvas"></canvas>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, onValue } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        
        let db = null;
        let mapImage = null;
        let tokens = [];
        let currentFog = { enabled: true, radius: 150 };
        let tokenImages = {};
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let lastMapData = null;
        let pendingRender = false; // Use RAF instead of flag

        const firebaseConfig = {
            apiKey: "AIzaSyBJeBvSKJucgU4UrWQVWSzexP9djl0wk0w",
            authDomain: "dnd-mapshare.firebaseapp.com",
            databaseURL: "https://dnd-mapshare-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "dnd-mapshare",
            storageBucket: "dnd-mapshare.firebasestorage.app",
            messagingSenderId: "624008039203",
            appId: "1:624008039203:web:46ee20fd32f7d8f4f95a96"
        };

        try {
            const app = initializeApp(firebaseConfig);
            db = getDatabase(app);
            statusEl.textContent = '⏳ Waiting for DM...';
            statusEl.className = 'status waiting';
            listenForUpdates();
        } catch (e) {
            statusEl.textContent = '✗ Connection failed';
            statusEl.className = 'status error';
            console.error('Firebase init error:', e);
        }

        function loadTokenImage(imagePath) {
            if (!tokenImages[imagePath]) {
                const img = new Image();
                img.onload = () => {
                    console.log('Token image loaded:', imagePath);
                    tokenImages[imagePath] = img;
                    // Don't call renderMap() here - it will be called by the main update
                };
                img.onerror = () => {
                    console.error('Failed to load token image:', imagePath);
                };
                img.src = imagePath;
            }
        }

        function listenForUpdates() {
            if (!db) return;
            
            const stateRef = ref(db, 'gameState');
            onValue(stateRef, (snapshot) => {
                const data = snapshot.val();
                
                console.log('=== PLAYER VIEW UPDATE ===');
                console.log('Zoom:', data?.zoom, 'Pan:', data?.pan);
                console.log('Tokens count:', data?.tokens?.length);
                
                if (!data) {
                    statusEl.textContent = '⏳ Waiting for DM to upload map...';
                    statusEl.className = 'status waiting';
                    return;
                }
                
                // Update fog settings
                if (data.fog) {
                    currentFog = data.fog;
                }
                
                // Update zoom/pan
                if (data.zoom !== undefined) {
                    zoom = data.zoom;
                }
                if (data.pan) {
                    panX = data.pan.x;
                    panY = data.pan.y;
                }
                
                // Update tokens - filter for players only
                tokens = (data.tokens || []).filter(t => t.type === 'player');
                tokens.forEach(token => {
                    if (token.image && !tokenImages[token.image]) {
                        loadTokenImage(token.image);
                    }
                });
                
                // Update map only if it changed
                if (data.mapData && data.mapData !== lastMapData) {
                    lastMapData = data.mapData;
                    console.log('Loading new map image');
                    const img = new Image();
                    img.onload = () => {
                        mapImage = img;
                        canvas.width = img.width;
                        canvas.height = img.height;
                        console.log('Map loaded, canvas size:', canvas.width, 'x', canvas.height);
                        scheduleRender();
                        statusEl.textContent = '✓ Connected';
                        statusEl.className = 'status';
                    };
                    img.onerror = () => {
                        console.error('Failed to load map image');
                        statusEl.textContent = '✗ Map load failed';
                        statusEl.className = 'status error';
                    };
                    img.src = data.mapData;
                } else if (mapImage) {
                    console.log('Scheduling render for update');
                    scheduleRender();
                }
            }, (error) => {
                statusEl.textContent = '✗ Connection error';
                statusEl.className = 'status error';
                console.error('Firebase read error:', error);
            });
        }

        let isRendering = false; // Prevent multiple simultaneous renders

        function scheduleRender() {
            if (!pendingRender) {
                pendingRender = true;
                requestAnimationFrame(() => {
                    pendingRender = false;
                    renderMap();
                });
            }
        }

        function renderMap() {
            if (!mapImage || isRendering) {
                return;
            }
            
            isRendering = true;

            console.log('=== RENDERING ===');
            console.log('Tokens to render:', tokens.length);
            console.log('Zoom:', zoom, 'Pan:', panX, panY);

            // Step 1: Completely reset and clear canvas
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Step 2: Apply transform once for everything
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-canvas.width / 2 + panX / zoom, -canvas.height / 2 + panY / zoom);
            
            // Step 3: Draw map
            ctx.drawImage(mapImage, 0, 0);

            const fog = currentFog || { enabled: false, radius: 150 };

            // Step 4: Draw all tokens
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                console.log(`Token ${i}: ${token.name} at (${token.x}, ${token.y})`);
                
                if (token.image && tokenImages[token.image]) {
                    const img = tokenImages[token.image];
                    
                    // Create a temporary path for clipping
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(token.x, token.y, 20, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(img, token.x - 20, token.y - 20, 40, 40);
                    ctx.restore();
                    
                    // Draw border
                    ctx.beginPath();
                    ctx.arc(token.x, token.y, 20, 0, Math.PI * 2);
                    ctx.strokeStyle = '#2a7fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.arc(token.x, token.y, 20, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(42, 127, 255, 0.8)';
                    ctx.fill();
                    ctx.strokeStyle = '#2a7fff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // Draw name
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(token.name, token.x, token.y + 23);
                ctx.fillText(token.name, token.x, token.y + 23);
            }

            // Step 5: Draw fog
            if (fog.enabled) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.globalCompositeOperation = 'destination-out';
                for (let i = 0; i < tokens.length; i++) {
                    const token = tokens[i];
                    const gradient = ctx.createRadialGradient(
                        token.x, token.y, fog.radius * 0.5,
                        token.x, token.y, fog.radius
                    );
                    gradient.addColorStop(0, 'rgba(0,0,0,1)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(token.x, token.y, fog.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalCompositeOperation = 'source-over';
            }
            
            // Step 6: Reset transform
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            isRendering = false;
            console.log('Render complete');
        }
    </script>
</body>
</html>